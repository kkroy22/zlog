<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>log::debug!</title>
	<link href="https://kkroy22.github.io/zlog/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://kkroy22.github.io/zlog"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-04-15T00:00:00+00:00</updated>
	<id>https://kkroy22.github.io/zlog/atom.xml</id>
	<entry xml:lang="en">
		<title>Elliptic Curves</title>
		<published>2022-04-15T00:00:00+00:00</published>
		<updated>2022-04-15T00:00:00+00:00</updated>
		<link href="https://kkroy22.github.io/zlog/elliptic-curves/" type="text/html"/>
		<id>https://kkroy22.github.io/zlog/elliptic-curves/</id>
		<content type="html">&lt;p&gt;Ellyptic curve on arbitery field. &lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;$$
1 +  \frac{q^2}{(1-q)}+\frac{q^6}{(1-q)(1-q^2)}+\cdots = \prod_{j=0}^{\infty}\frac{1}{(1-q^{5j+2})(1-q^{5j+3})}, \quad\quad \text{for }\lvert q\rvert&amp;lt;1
$$&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Merkel Tree</title>
		<published>2022-04-15T00:00:00+00:00</published>
		<updated>2022-04-15T00:00:00+00:00</updated>
		<link href="https://kkroy22.github.io/zlog/merkel-tree/" type="text/html"/>
		<id>https://kkroy22.github.io/zlog/merkel-tree/</id>
		<content type="html">&lt;p&gt;Merkle Trees are used in popular software applications like Git, Amazon Dynamo DB and BlockChain. A merkle tree is a metadata-structure, which stores the hash of the combined children in each parent. Any change in a child requires a change in the parent node. &lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;This property of identifying state changes is useful when validating the correctness of data, as calculating the inverse of a hash is computationally infeasible. The merkle tree&#x27;s properties are suitable for applications where a malicious user must be stopped from changing data.&lt;&#x2F;p&gt;
&lt;p&gt;Git file creation details:
Git registers any change in a file as an entirely new file. It stores the content of the file with a filename of SHA1(fileContents). Let&#x27;s say this SHA1(fileContents) = x. If x already exists in the git file system, it doesn&#x27;t go ahead and create it. This avoids unnecessary recreations when metadata about a file is changed.&lt;&#x2F;p&gt;
&lt;p&gt;When a file is modified in Git, git creates a new (changed)file, and all it&#x27;s changed parents. The root subsequently changes. It&#x27;s like a branch of a Persistent Data Structure. If you want to go back a commit, you use the root of the previous commit, which still points to the old file. &lt;&#x2F;p&gt;
&lt;p&gt;In this way, Git takes snapshots of every point of change in the project. Perfect for a version control system.&lt;&#x2F;p&gt;
&lt;p&gt;It is also useful to find the points at which the data has changed, using a Merkle Tree. Amazon Dynamo DB uses merkle trees to reduce entropy (Anti-entropy technique) when a new node is added to the Dynamo DB cluster.&lt;&#x2F;p&gt;
&lt;p&gt;Amazon Dynamo DB data migration details:
When copying a range assigned to a node, we have to allow concurrent updates to keep the service available. But when the migration is in progress, concurrent updates lead to stale data in the destination node.&lt;&#x2F;p&gt;
&lt;p&gt;So we copy the data range multiple times. When there is no change in the two nodes, we declare the destination node as consistent. Since we want this to happen as fast as possible, we try to minimise the number of copy iterations. The procedure is explained in the video.&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
